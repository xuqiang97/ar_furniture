<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Furniture Placement</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
  <div id="container" style="width: 100%; height: 100%; position: relative;"></div>
  <script>
    let camera, scene, renderer, model;
    let container = document.getElementById("container");

    // Initialize Three.js Scene
    async function init() {
      scene = new THREE.Scene();

      // Set up camera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // Add ambient lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 1); // Increased intensity
      scene.add(ambientLight);

      // Add directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 10, 10);
      scene.add(dirLight);

      // Access camera stream and set as background
      await setupCameraBackground();

      // Load 3D model (example: a cube as a placeholder for furniture)
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      model = new THREE.Mesh(geometry, material);

      // Place model in front of the camera
      model.position.set(0, 0, -3);
      scene.add(model);

      // Enable dragging and scaling
      enableDragAndScale(model);

      // Handle resizing
      window.addEventListener("resize", onWindowResize, false);

      animate();
    }

    // Handle window resizing
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Set up device camera as background
    async function setupCameraBackground() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" }
        });
        const video = document.createElement("video");
        video.srcObject = stream;
        video.play();

        // Create video texture and set as scene background
        const videoTexture = new THREE.VideoTexture(video);

        // Create a separate background scene
        const bgScene = new THREE.Scene();
        const bgCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const bgMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
        const bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), bgMaterial);
        bgScene.add(bgPlane);

        // Store background scene and camera for rendering
        scene.userData.bgScene = bgScene;
        scene.userData.bgCamera = bgCamera;
      } catch (error) {
        console.error("Error accessing camera:", error);
      }
    }

    // Enable dragging and scaling for model
    function enableDragAndScale(object) {
      let isDragging = false;
      let previousTouchDistance = null;

      container.addEventListener("touchstart", (event) => {
        if (event.touches.length === 1) {
          isDragging = true;
        } else if (event.touches.length === 2) {
          isDragging = false; // Stop dragging during pinch
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          previousTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });

      container.addEventListener("touchmove", (event) => {
        if (isDragging && event.touches.length === 1) {
          const touch = event.touches[0];
          const movementX = touch.movementX || touch.pageX - touch.clientX;
          const movementY = touch.movementY || touch.pageY - touch.clientY;

          object.position.x += movementX * 0.01;
          object.position.y -= movementY * 0.01;
        } else if (event.touches.length === 2) {
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          const touchDistance = Math.sqrt(dx * dx + dy * dy);

          if (previousTouchDistance) {
            const scaleDelta = touchDistance / previousTouchDistance;
            object.scale.multiplyScalar(scaleDelta);
          }

          previousTouchDistance = touchDistance;
        }
      });

      container.addEventListener("touchend", () => {
        isDragging = false;
        previousTouchDistance = null;
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Render the background scene
      if (scene.userData.bgScene && scene.userData.bgCamera) {
        renderer.autoClear = false;
        renderer.clear();
        renderer.render(scene.userData.bgScene, scene.userData.bgCamera);
      }

      // Render the main scene
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
