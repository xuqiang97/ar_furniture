<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Furniture Placement</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
  <div id="container" style="width: 100%; height: 100%; position: relative;"></div>
  <script>
    let camera, scene, renderer, model;
    let container = document.getElementById("container");

    // Initialize Three.js Scene
    function init() {
      scene = new THREE.Scene();

      // Set up camera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // Add ambient lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      // Add directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(10, 10, 10);
      scene.add(dirLight);

      // Add a placeholder ground plane
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.MeshStandardMaterial({ color: 0xeeeeee })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Load 3D model (example: a cube as a placeholder for furniture)
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      model = new THREE.Mesh(geometry, material);
      scene.add(model);

      // Enable dragging and scaling
      enableDragAndScale(model);

      // Access camera stream
      setupCameraBackground();

      // Handle resizing
      window.addEventListener("resize", onWindowResize, false);
    }

    // Handle window resizing
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Set up device camera as background
    async function setupCameraBackground() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" }
        });
        const video = document.createElement("video");
        video.srcObject = stream;
        video.play();

        const videoTexture = new THREE.VideoTexture(video);
        const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
        const videoPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(16, 9),
          videoMaterial
        );
        videoPlane.scale.set(1.5, 1.5, 1); // Scale to fit screen
        scene.add(videoPlane);
        videoPlane.position.z = -5;
      } catch (error) {
        console.error("Error accessing camera:", error);
      }
    }

    // Enable dragging and scaling for model
    function enableDragAndScale(object) {
      let isDragging = false;
      let previousTouchDistance = null;

      container.addEventListener("touchstart", (event) => {
        if (event.touches.length === 1) {
          isDragging = true;
        } else if (event.touches.length === 2) {
          isDragging = false; // Stop dragging during pinch
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          previousTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });

      container.addEventListener("touchmove", (event) => {
        if (isDragging && event.touches.length === 1) {
          const touch = event.touches[0];
          const movementX = touch.movementX || touch.pageX - touch.clientX;
          const movementY = touch.movementY || touch.pageY - touch.clientY;

          object.position.x += movementX * 0.01;
          object.position.y -= movementY * 0.01;
        } else if (event.touches.length === 2) {
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          const touchDistance = Math.sqrt(dx * dx + dy * dy);

          if (previousTouchDistance) {
            const scaleDelta = touchDistance / previousTouchDistance;
            object.scale.multiplyScalar(scaleDelta);
          }

          previousTouchDistance = touchDistance;
        }
      });

      container.addEventListener("touchend", () => {
        isDragging = false;
        previousTouchDistance = null;
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
