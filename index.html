<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Furniture Placement</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
  <div id="container" style="width: 100%; height: 100%; position: relative;"></div>
  <script>
    let camera, scene, renderer, model;
    let container = document.getElementById("container");

    // Initialize Three.js Scene
    async function init() {
      scene = new THREE.Scene();

      // Set up camera
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 5);

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // Add ambient lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      // Add directional light
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(10, 10, 10);
      scene.add(dirLight);

      // Access camera stream and set as background
      await setupCameraBackground();

      // Load 3D model (example: a cube as a placeholder for furniture)
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      model = new THREE.Mesh(geometry, material);
      model.position.set(0, 1, 0); // 保证模型在视野内
      model.scale.set(1, 1, 1);
      scene.add(model);

      // Enable dragging and scaling
      enableDragAndScale(model);

      // Handle resizing
      window.addEventListener("resize", onWindowResize, false);

      animate();
    }

    // Handle window resizing
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Set up device camera as background
    async function setupCameraBackground() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" }
        });
        const video = document.createElement("video");
        video.setAttribute("autoplay", "");
        video.setAttribute("muted", "");
        video.setAttribute("playsinline", "");
        video.srcObject = stream;
        await video.play();

        // Create video texture and set as scene background
        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBFormat;
        scene.background = videoTexture;
      } catch (error) {
        alert("无法访问摄像头，请检查权限设置");
        console.error("Error accessing camera:", error);
      }
    }

    // Enable dragging and scaling for model (only affects model, not camera or background)
    function enableDragAndScale(object) {
      let isDragging = false;
      let previousTouchDistance = null;
      let lastTouch = { x: 0, y: 0 };

      // 限制模型移动范围
      function clampModelPosition() {
        object.position.x = Math.max(-5, Math.min(5, object.position.x));
        object.position.y = Math.max(0, Math.min(5, object.position.y));
      }

      container.addEventListener("touchstart", (event) => {
        if (event.touches.length === 1) {
          isDragging = true;
          lastTouch.x = event.touches[0].pageX;
          lastTouch.y = event.touches[0].pageY;
        } else if (event.touches.length === 2) {
          isDragging = false;
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          previousTouchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });

      container.addEventListener("touchmove", (event) => {
        if (isDragging && event.touches.length === 1) {
          const touch = event.touches[0];
          const movementX = touch.pageX - lastTouch.x;
          const movementY = touch.pageY - lastTouch.y;
          object.position.x += movementX * 0.01;
          object.position.y -= movementY * 0.01;
          clampModelPosition();
          lastTouch.x = touch.pageX;
          lastTouch.y = touch.pageY;
        } else if (event.touches.length === 2) {
          event.preventDefault(); // Prevent page zoom/scroll, crucial for mobile
          const dx = event.touches[0].pageX - event.touches[1].pageX;
          const dy = event.touches[0].pageY - event.touches[1].pageY;
          const touchDistance = Math.sqrt(dx * dx + dy * dy);

          if (previousTouchDistance) {
            let scaleDelta = touchDistance / previousTouchDistance;
            let newScale = object.scale.x * scaleDelta;
            newScale = Math.max(0.1, Math.min(5, newScale));
            object.scale.set(newScale, newScale, newScale);
          }
          previousTouchDistance = touchDistance;
        }
      }, { passive: false });

      container.addEventListener("touchend", () => {
        isDragging = false;
        previousTouchDistance = null;
      });
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      if (model) model.visible = true; // 保证模型可见
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
