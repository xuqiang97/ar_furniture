<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D 家具 AR Demo</title>
  <style>
    html, body { width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden;}
    #container { width: 100vw; height: 100vh; position: relative; }
    canvas { display: block; }
  </style>
</head>
<body>
<div id="container"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
<script>
(async function() {
  const container = document.getElementById('container');
  const width = container.clientWidth;
  const height = container.clientHeight;
  const aspect = width / height;

  // 1. 获取摄像头
  const constraints = {
    video: {
      facingMode: 'environment',
      aspectRatio: aspect,
      width: { ideal: width },
      height: { ideal: height }
    }
  };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  const video = document.createElement('video');
  video.setAttribute('autoplay', '');
  video.setAttribute('playsinline', '');
  video.srcObject = stream;

  await new Promise(res => {
    video.onloadedmetadata = () => {
      video.play();
      res();
    };
  });

  // 2. Three.js 场景
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, aspect, 0.01, 1000);
  camera.position.set(0, 1.6, 3);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setClearAlpha(0);
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);

  // 3. 用 VideoTexture 做背景
  const videoTexture = new THREE.VideoTexture(video);
  scene.background = videoTexture;

  // 4. 加载 GLTF 家具模型
  let furniture;
  const loader = new THREE.GLTFLoader();
  loader.load(
    // 你可以替换成自己的 glb/gltf 文件
    'https://threejs.org/examples/models/gltf/Chair/Chair.gltf',
    gltf => {
      furniture = gltf.scene;
      furniture.position.set(0, 0, 0);
      furniture.scale.set(1.2, 1.2, 1.2);
      scene.add(furniture);

      // 5. 启用手势交互
      enableGestures(furniture);
    },
    xhr => { /* 可选进度回调 */ },
    err => { alert('模型加载失败:' + err); }
  );

  // 6. 响应式自适应
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });

  // 7. 渲染主循环
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // 8. 手势交互
  function enableGestures(object) {
    const mc = new Hammer.Manager(renderer.domElement);

    // 拖拽
    const pan = new Hammer.Pan({ threshold: 0, pointers: 1 });
    mc.add(pan);

    // 缩放
    const pinch = new Hammer.Pinch();
    mc.add(pinch);

    // 旋转
    const rotate = new Hammer.Rotate();
    mc.add(rotate);

    // 组合
    pinch.recognizeWith(rotate);

    // 记录初始状态
    let lastPan = { x: 0, y: 0 };
    let lastScale = 1;
    let lastRotation = 0;
    let startPosition = new THREE.Vector3();
    let startScale = new THREE.Vector3();
    let startRotationY = 0;

    // 拖拽
    mc.on('panstart', ev => {
      lastPan.x = ev.center.x;
      lastPan.y = ev.center.y;
      startPosition.copy(object.position);
    });

    mc.on('panmove', ev => {
      // 这里假设拖拽在X、Z平面上，y轴高度不变
      const deltaX = (ev.center.x - lastPan.x) / width * 5; // 5是场景宽度的近似缩放
      const deltaY = (ev.center.y - lastPan.y) / height * 5;
      object.position.x = startPosition.x + deltaX;
      object.position.z = startPosition.z + deltaY;

      // 边界限制（示例：可自定义/自适应）
      const bounds = 2.5;
      object.position.x = Math.max(-bounds, Math.min(bounds, object.position.x));
      object.position.z = Math.max(-bounds, Math.min(bounds, object.position.z));
    });

    // 缩放
    mc.on('pinchstart', ev => {
      lastScale = ev.scale;
      object.getWorldScale(startScale);
    });
    mc.on('pinchmove', ev => {
      const scale = startScale.x * ev.scale / lastScale;
      object.scale.setScalar(Math.max(0.3, Math.min(2.5, scale)));
    });

    // 旋转
    mc.on('rotatestart', ev => {
      lastRotation = ev.rotation;
      startRotationY = object.rotation.y;
    });
    mc.on('rotatemove', ev => {
      object.rotation.y = startRotationY + (ev.rotation - lastRotation) * Math.PI / 180;
    });

    // 阻止默认行为
    renderer.domElement.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    renderer.domElement.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
    renderer.domElement.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  }
})();
</script>
</body>
</html>
